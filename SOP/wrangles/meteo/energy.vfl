#include "assert.h"


// (volume) light_incidence_sum :: V -> F -> F
float light_incidence_sum(vector lightDir, float distanceToLight){

    assert(length(lightDir)==1);
    assert(distanceToLight>0);

    float dotProductFace = 0.0;
    float dotProductFaceSum = 0.0;

    // Calculate the length of one of the faces of the voxel using the diameter and the formula for the 
    // length of a face of a regular cube (d / sqrt(3))
    float diameter = volumevoxeldiameter(0, 0);
    float faceLength = d / sqrt(3);
    // Calculate the area of one of the faces of the voxel using the face length
    float faceArea = face_length*face_length;


    // Normalize the light direction if it is nor already normalized
    //lightDir = normalize(lightDir);


    // Define an array of vectors to store the directions of the faces of the cube
    vector[] faceDirs = {
        {1,0,0}, // +X direction
        {0,1,0}, // +Y direction
        {0,0,1}, // +Z direction
        {-1,0,0}, // -X direction
        {0,-1,0}, // -Y direction
        {0,0,-1} // -Z direction
    };

    // Iterate over the array and print each direction
    foreach (vector dir; faceDirs) {
        //printf("Direction: %s\n", dir);
        // Calculate the dot product of the surface normal and the light direction
        float dotProduct = dot(dir, lightDir);
        // The total incident light over the face if facing the light direction
        if (dotProduct>0){
            dotProductFace = dotProduct * faceArea;
            dotProductFaceSum += dotProductFace;
        }
    }
    // Return the sum of all incident light 
    return dotProductFaceSum;

} // light_incidence_sum


// (volume) raymarch_vol :: V -> F -> F -> F -> F -> Str -> F
vector raymarch_vol(vector dir, 
                    float distMax, 
                    float epsilonMin, 
                    float epsilonMax,
                    float opticalDensityLimit = 10.0,
                    string volumeFieldName = "density"
                    ) 
                    {

    // Normalize the ray direction and clamp some values
    dir = normalize(dir);
    epsilonMin = clamp(epsilonMin, 0.0, distMax);
    epsilonMax = clamp(epsilonMax, 0.0, distMax);
    opticalDensityLimit = clamp(opticalDensityLimit, 0.0 , 1000.0);

    // Initialize the raymarching variables
    float dist = 0.0;
    float stepSize = epsilonMin;
    float opticalDensity = 0.0;
    vector pos = v@P;

    // Variables used to increase stepsize if it appears 
    // to march through an empty region.
    int zeroCounter = 0;  
    int zeroThreshold = 10; 
    int zeroMultiplier = 2;

    // March the ray through the volume
    while (dist < distMax && opticalDensity < opticalDensityLimit) {

        // Sample the density at the current position
        opticalDensity += volumesample(0, volumeFieldName, pos);


        // Check if the current optical density is zero
        if (opticalDensity == 0) {
            zeroCounter++;  // Increment the counter
        } else {
            zeroCounter = 0;  // Reset the counter
        }
        // Increase the step size if the counter has reached the threshold
        if (zeroCounter >= zeroThreshold) {
            stepSize *= zeroMultiplier;
        }


        // Move the ray to the next position
        dist += stepSize;
        pos += stepSize * dir;
        // New stepSize
        stepsize = fit(dist, 0.0, distMax, epsilonMin, epsilonMax);
    }

  // Return the final optical density value
  return opticalDensity;   


}